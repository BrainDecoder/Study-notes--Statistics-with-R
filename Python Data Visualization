#PANDAS BASICS

import numpy as np  # useful for many scientific computing in Python
import pandas as pd # primary data structure library
df_can = pd.read_excel('https://.../Canada.xlsx',
                       sheet_name='Canada by Citizenship',
                       skiprows=range(20),
                       skipfooter=2)
df_can.columns.values #get the list of column headers
df_can.index.values #get the list of indicies
df_can.columns.tolist() # Get the index and columns as lists
df_can.index.tolist()
df_can['Total'] = df_can.sum(axis=1) # Add a 'Total' column
df_can.isnull().sum() #check to see how many null objects there are
df_can.set_index('Country', inplace=True) #use 'Country' column as the index
df_can.index.name = None #optional: remove the name of the index

# 3 ways to view all data in a row
print(df_can.loc['Japan'])
print(df_can.iloc[87])
print(df_can[df_can.index == 'Japan'].T.squeeze())
# 3 ways to view data in a raw and specific columns
print(df_can.loc['Japan', [1980, 1981, 1982, 1983, 1984, 1984]])
print(df_can.iloc[87, [3, 4, 5, 6, 7, 8]])
# To avoid confusion, integer column names should be converted into strings
df_can.columns = list(map(str, df_can.columns))
# Declare a variable to allow easily call the full range of years (sting column names)
years = list(map(str, range(1980, 2014)))
# Filter by condition
condition = df_can['Continent'] == 'Asia'
df_can[condition]
df_can[(df_can['Continent']=='Asia') & (df_can['Region']=='Southern Asia')]

#BASIC VIZ WITH MATPLOTLIB

import matplotlib as mpl
import matplotlib.pyplot as plt
print ('Matplotlib version: ', mpl.__version__) 
# Optional: apply a style to Matplotlib
print(plt.style.available) #list of styles
mpl.style.use(['ggplot']) # optional: for ggplot-like style
# Extract the required data series 
haiti = df_can.loc['Haiti', years]
haiti.plot() #automatic plot

# Line Plot
haiti.index = haiti.index.map(int) #change index values to type integer for plotting
haiti.plot(kind='line')
plt.title('Immigration from Haiti')
plt.ylabel('Number of immigrants')
plt.xlabel('Years')
plt.text(2000, 6000, '2010 Earthquake') #coment on the plot: plt.text(x, y, label)
#plt.text(20, 6000, '2010 Earthquake') - for years as strings, 20 is index position
plt.show() #show the updates made to the figure

# Plot several rows
df_CI = df_can.loc[['India', 'China'], years]
df_CI.plot(kind='line')
df_CI = df_CI.transpose() #if data orientation is wrong, not required for haiti as it's a series, not dataframe
df_CI.index = df_CI.index.map(int)
df_CI.plot(kind='line')
plt.title('Immigrants from China and India')
plt.ylabel('Number of Immigrants')
plt.xlabel('Years')
plt.show()

# OTHER PLOTS
# `bar` for vertical bar plots
# `barh` for horizontal bar plots
# `hist` for histogram
# `box` for boxplot
# `kde` or `density` for density plots
# `area` for area plots
# `pie` for pie plots
# `scatter` for scatter plots
# `hexbin` for hexbin plot

# COLORS
import matplotlib
for name, hex in matplotlib.colors.cnames.items():
    print(name, hex)

# Area Plot
# Separate the top 5 countries
df_can.sort_values(['Total'], ascending=False, axis=0, inplace=True) #sort desc.
df_top5 = df_can.head() # get the top 5 entries
df_top5 = df_top5[years].transpose() # transpose the dataframe
df_top5.head() #show result
# Draw area plot
df_top5.index = df_top5.index.map(int) # change index values to integer
df_top5.plot(kind='area', #type of plot
             alpha=0.25, #transparancy, 0-1 values, default a=0.5
             stacked=False, #True by default for area plots = all NaN will be made 0
             figsize=(20, 10), # pass a tuple (x, y) size
            )
plt.title('Immigration Trend of Top 5 Countries')
plt.ylabel('Number of Immigrants')
plt.xlabel('Years')
plt.show()

# Histograms
count, bin_edges = np.histogram(df_can['2013']) # returns 2 values
print(count) # frequency count
print(bin_edges) # bin ranges, default = 10 bins
df_can['2013'].plot(kind='hist', figsize=(8, 5), xticks=bin_edges) # same as df_can['2013'].plot.hist()
plt.title('Histogram of Immigration from 195 Countries in 2013')
plt.ylabel('Number of Countries') # add y-label
plt.xlabel('Number of Immigrants') # add x-label
plt.show()
# Multiple histogram
df_can.loc[['Denmark', '...', 'Sweden'], years].plot.hist() # generate histogram
df_t = df_can.loc[['Denmark', '...', 'Sweden'], years].transpose() #if previous gives wrong graph
count, bin_edges = np.histogram(df_t, 15) # get the x-tick values
xmin = bin_edges[0] - 10 #adding buffer of 10 to the first bin for aesthetic purposes 
xmax = bin_edges[-1] + 10 # same for the last bin value
df_t.plot(kind ='hist', 
          figsize=(10, 6),
          bins=15, #increase the bin size
          alpha=0.6, #set transparency to 60%
          xticks=bin_edges,
          color=['coral', 'darkslateblue', 'mediumseagreen'],
          stacked = True, #if plots should not overlap each other
          xlim=(xmin, xmax)
         )
plt.title('Histogram of Immigration from Denmark, Norway, and Sweden from 1980 - 2013')
plt.ylabel('Number of Years')
plt.xlabel('Number of Immigrants')
plt.show()

# Bar Charts
df_iceland = df_can.loc['Iceland', years] #get the data
df_iceland.plot(kind='bar', figsize=(10, 6), color='steelblue', rot=90) #barh for horizontal bars, ?rot rotates bars by 90 degrees?
plt.xlabel('Year') # add to x-label to the plot
plt.ylabel('Number of immigrants') # add y-label to the plot
plt.title('Icelandic immigrants to Canada from 1980 to 2013') # add title to the plot
plt.annotate(        #annotate arrow 
    '',              #string, blank here
    xy=(32, 70),     #head of the arrow at point (year 2012 , pop 70)
    xytext=(28, 20), #base of the arrow at point (year 2008 , pop 20)
    xycoords='data', #will use the coordinate system of the object being annotated 
    arrowprops=dict(arrowstyle='->', connectionstyle='arc3', color='blue', lw=2)
    #-> = standard style, arc3 = straight line, lw = line width
    )
plt.annotate(        #annotate Text
    '2008 - 2011 Financial Crisis', # text to display
    xy=(28, 30),     # start the text at at point (year 2008 , pop 30)
    rotation=72.5,   # based on trial and error to match the arrow
    va='bottom',     # want the text to be vertically 'bottom' aligned
    ha='left')       # want the text to be horizontally 'left' algned
for index, value in enumerate(df_can): # annotate value labels to each country
    label = format(int(value), ',') # format int with commas
    # place text at the end of bar (subtracting 47000 from x, and 0.1 from y to make it fit within the bar)
    plt.annotate(label, xy=(value - 47000, index - 0.10), color='white')
plt.show()

#SPECIALIZED VIZ

# Pie Charts
df_continents = df_can.groupby('Continent', axis=0).sum() #prep data
colors_list = ['gold', '...', 'pink']
explode_list = [0.1, 0, 0, 0, 0.1, 0.1] # ratio for each continent with which to offset each wedge
df_continents['Total'].plot(kind='pie',
        figsize=(15, 6),
        autopct='%1.1f%%', #labels the wedges with their numeric value; fmt%pct for string format
        startangle=90,    
        shadow=True,       
        labels=None,         # turn off labels on pie chart
        pctdistance=1.12,    # the ratio between the center of each pie slice and the start of the text generated by autopct 
        colors=colors_list,  # add custom colors
        explode=explode_list # 'explode' lowest 3 continents
        )
plt.title('Immigration to Canada by Continent [1980 - 2013]', y=1.12) #scale by 12%
plt.axis('equal') #sets the pie chart to look like a circle.
plt.legend(labels=df_continents.index, loc='upper left') 
plt.show()

# Box Plots
df_japan = df_can.loc[['Japan'], years].transpose() #extra brackets to get a dataframe
df_japan.plot(kind='box', figsize=(8, 6)) #color for color, vert=False for horizontal view
plt.title('Box plot of Japanese Immigrants from 1980 - 2013')
plt.ylabel('Number of Immigrants')
plt.show()

# Subplots
fig = plt.figure() # create figure
ax0 = fig.add_subplot(1, 2, 1) # add subplot 1 (1 row, 2 columns, first plot)
ax1 = fig.add_subplot(1, 2, 2) # add subplot 2 (1 row, 2 columns, second plot)
# Subplot 1: Box plot
df_CI.plot(kind='box', color='blue', vert=False, figsize=(20, 6), ax=ax0) # add to subplot 1
ax0.set_title('Box Plots of Immigrants from China and India (1980 - 2013)')
ax0.set_xlabel('Number of Immigrants')
ax0.set_ylabel('Countries')
# Subplot 2: Line plot
df_CI.plot(kind='line', figsize=(20, 6), ax=ax1) # add to subplot 2
ax1.set_title ('Line Plots of Immigrants from China and India (1980 - 2013)')
ax1.set_ylabel('Number of Immigrants')
ax1.set_xlabel('Years')
plt.show()

# Scatter Plots
df_tot = pd.DataFrame(df_can[years].sum(axis=0)) #get total population per year
df_tot.index = map(int, df_tot.index) #for regression change years to int
df_tot.reset_index(inplace = True) #reset the index
# Fit regression line
x = df_tot['year']
y = df_tot['total']
fit = np.polyfit(x, y, deg=1)
# Print plot
df_tot.plot(kind='scatter', x='year', y='total', figsize=(10, 6), color='darkblue')
plt.title('Total Immigration to Canada from 1980 - 2013')
plt.xlabel('Year')
plt.ylabel('Number of Immigrants')
plt.plot(x, fit[0] * x + fit[1], color='red') # x is the Years
plt.annotate('y={0:.0f} x + {1:.0f}'.format(fit[0], fit[1]), xy=(2000, 150000))
plt.show()
'No. Immigrants = {0:.0f} * Year + {1:.0f}'.format(fit[0], fit[1]) # just a comment

# Bubble Plots
df_can_t = df_can[years].transpose() #transposed dataframe
df_can_t.index = map(int, df_can_t.index) #cast the Years (the index) to type int
df_can_t.index.name = 'Year' #automatically becomes column name when index is reset
df_can_t.reset_index(inplace=True) #reset index to bring the Year in as a column
# Create the normalized weights
norm_brazil = (df_can_t['Brazil'] - df_can_t['Brazil'].min()) / (df_can_t['Brazil'].max() - df_can_t['Brazil'].min())
norm_argentina = (df_can_t['Argentina'] - df_can_t['Argentina'].min()) / (df_can_t['Argentina'].max() - df_can_t['Argentina'].min())
# Plot the data
ax0 = df_can_t.plot(kind='scatter',
      x='Year',
      y='Brazil',
      figsize=(14, 8),
      alpha=0.5,
      color='green',
      s=norm_brazil * 2000 + 10, #pass in weights; 2000 to scale up on the graph
      xlim=(1975, 2015))
ax1 = df_can_t.plot(kind='scatter',
      x='Year',
      y='Argentina',
      alpha=0.5,
      color="blue",
      s=norm_argentina * 2000 + 10, #10 to compensate for the min value
      ax = ax0)
ax0.set_ylabel('Number of Immigrants')
ax0.set_title('Immigration from Brazil and Argentina from 1980 - 2013')
ax0.legend(['Brazil', 'Argentina'], loc='upper left', fontsize='x-large')

# ADVANCED PLOTS

# Waffle Charts
import matplotlib.patches as mpatches # needed for waffle Charts
df_dsn = df_can.loc[['Denmark', 'Norway', 'Sweden'], :] #create a new dataframe
# compute the proportion of each category with respect to the total
total_values = sum(df_dsn['Total'])
category_proportions = [(float(value) / total_values) for value in df_dsn['Total']]
# print out proportions
for i, proportion in enumerate(category_proportions):
    print (df_dsn.index.values[i] + ': ' + str(proportion))
# Define the overall size of the waffle chart
width = 40 # width of chart
height = 10 # height of chart
total_num_tiles = width * height # total number of tiles
print ('Total number of tiles is ', total_num_tiles)
# Using the proportion of each category determe its respective number of tiles
tiles_per_category = [round(proportion * total_num_tiles) for proportion in category_proportions]
for i, tiles in enumerate(tiles_per_category):
    print (df_dsn.index.values[i] + ': ' + str(tiles))
# Creating the matrix
waffle_chart = np.zeros((height, width)) #initialize the waffle chart as an empty matrix
category_index = 0 # define indices to loop through waffle chart
tile_index = 0
#populate the waffle chart
for col in range(width):
    for row in range(height):
        tile_index += 1
        # if the number of tiles populated for the current category is equal to its corresponding allocated tiles...
        if tile_index > sum(tiles_per_category[0:category_index]):
            # ...proceed to the next category
            category_index += 1       
        # set the class value to an integer, which increases with class
        waffle_chart[row, col] = category_index
print ('Waffle chart populated!')
waffle_chart #shows the matrix, numbers no pictures yet
# Map the waffle chart matrix into a visual
fig = plt.figure() #instantiate a new figure object
colormap = plt.cm.coolwarm #use matshow to display the waffle chart
plt.matshow(waffle_chart, cmap=colormap)
plt.colorbar()
ax = plt.gca() #get the axis
ax.set_xticks(np.arange(-.5, (width), 1), minor=True) #set minor ticks
ax.set_yticks(np.arange(-.5, (height), 1), minor=True)
ax.grid(which='minor', color='w', linestyle='-', linewidth=2) #add gridlines based on minor ticks
plt.xticks([])
plt.yticks([])
# compute cumulative sum of individual categories to match color schemes between chart and legend
values_cumsum = np.cumsum(df_dsn['Total'])
total_values = values_cumsum[len(values_cumsum) - 1]
# Create legend
legend_handles = []
for i, category in enumerate(df_dsn.index.values):
    label_str = category + ' (' + str(df_dsn['Total'][i]) + ')'
    color_val = colormap(float(values_cumsum[i])/total_values)
    legend_handles.append(mpatches.Patch(color=color_val, label=label_str))
plt.legend(handles=legend_handles, #add legend to chart
           loc='lower center', 
           ncol=len(df_dsn.index.values),
           bbox_to_anchor=(0., -0.2, 0.95, .1)
          )

# Waffle Chart as one function
def create_waffle_chart(categories, values, height, width, colormap, value_sign=''):
    # compute the proportion of each category with respect to the total
    total_values = sum(values)
    category_proportions = [(float(value) / total_values) for value in values]
    # compute the total number of tiles
    total_num_tiles = width * height # total number of tiles
    print ('Total number of tiles is', total_num_tiles)
        # compute the number of tiles for each catagory
    tiles_per_category = [round(proportion * total_num_tiles) for proportion in category_proportions]
    # print out number of tiles per category
    for i, tiles in enumerate(tiles_per_category):
        print (df_dsn.index.values[i] + ': ' + str(tiles))
    # initialize the waffle chart as an empty matrix
    waffle_chart = np.zeros((height, width))
    # define indices to loop through waffle chart
    category_index = 0
    tile_index = 0
    # populate the waffle chart
    for col in range(width):
        for row in range(height):
            tile_index += 1
            # if the number of tiles populated for the current category 
            # is equal to its corresponding allocated tiles...
            if tile_index > sum(tiles_per_category[0:category_index]):
                # ...proceed to the next category
                category_index += 1  
            # set the class value to an integer, which increases with class
            waffle_chart[row, col] = category_index
    # instantiate a new figure object
    fig = plt.figure()
    # use matshow to display the waffle chart
    colormap = plt.cm.coolwarm
    plt.matshow(waffle_chart, cmap=colormap)
    plt.colorbar()
    # get the axis
    ax = plt.gca()
    # set minor ticks
    ax.set_xticks(np.arange(-.5, (width), 1), minor=True)
    ax.set_yticks(np.arange(-.5, (height), 1), minor=True)
    # add dridlines based on minor ticks
    ax.grid(which='minor', color='w', linestyle='-', linewidth=2)
    plt.xticks([])
    plt.yticks([])
    # compute cumulative sum of individual categories to match color schemes between chart and legend
    values_cumsum = np.cumsum(values)
    total_values = values_cumsum[len(values_cumsum) - 1]
    # create legend
    legend_handles = []
    for i, category in enumerate(categories):
        if value_sign == '%':
            label_str = category + ' (' + str(values[i]) + value_sign + ')'
        else:
            label_str = category + ' (' + value_sign + str(values[i]) + ')'
            
        color_val = colormap(float(values_cumsum[i])/total_values)
        legend_handles.append(mpatches.Patch(color=color_val, label=label_str))
    # add legend to chart
    plt.legend(
        handles=legend_handles,
        loc='lower center', 
        ncol=len(categories),
        bbox_to_anchor=(0., -0.2, 0.95, .1)
    )
width = 40 # width of chart
height = 10 # height of chart
categories = df_dsn.index.values # categories
values = df_dsn['Total'] # correponding values of categories
colormap = plt.cm.coolwarm # color map class
create_waffle_chart(categories, values, height, width, colormap)

# Word Clouds
from PIL import Image # converting images into arrays
#!conda install -c conda-forge wordcloud==1.4.1 --yes #install wordcloud
from wordcloud import WordCloud, STOPWORDS #import package and its set of stopwords
alice_novel = open('alice_novel.txt', 'r').read()
stopwords = set(STOPWORDS) #use function set to remove any redundant stopwords
alice_wc = WordCloud( #instantiate a word cloud object
    background_color='white',
    max_words=2000,
    stopwords=stopwords
)
alice_wc.generate(alice_novel) #generate the word cloud
plt.imshow(alice_wc, interpolation='bilinear') #display the word cloud
plt.axis('off')
plt.show()
# Resize the cloud
fig = plt.figure()
fig.set_figwidth(14) #set width
fig.set_figheight(18) #set height
plt.imshow(alice_wc, interpolation='bilinear')
plt.axis('off')
plt.show()
# Add stopwords and re-generate the cloud
stopwords.add('said') #add the words said to stopwords
alice_wc.generate(alice_novel) #re-generate the word cloud
fig = plt.figure() # display the cloud
fig.set_figwidth(14) #set width
fig.set_figheight(18) #set height
plt.imshow(alice_wc, interpolation='bilinear')
plt.axis('off')
plt.show()
# Superimposing the words onto a mask/picture
alice_mask = np.array(Image.open('alice_mask.png')) #save mask to alice_mask
# Look at how the mask looks like
fig = plt.figure()
fig.set_figwidth(14) # set width
fig.set_figheight(18) # set height
plt.imshow(alice_mask, cmap=plt.cm.gray, interpolation='bilinear')
plt.axis('off')
plt.show()
# Shaping the word cloud according to the mask
alice_wc = WordCloud(background_color='white', max_words=2000, mask=alice_mask, stopwords=stopwords) #instantiate a word cloud object
alice_wc.generate(alice_novel) #generate the word cloud
fig = plt.figure() #display the word cloud
fig.set_figwidth(14) # set width
fig.set_figheight(18) # set height
plt.imshow(alice_wc, interpolation='bilinear')
plt.axis('off')
plt.show()

# Seaborn library
#!conda install -c anaconda seaborn --yes #install if required
import seaborn as sns #import library
df_tot = pd.DataFrame(df_can[years].sum(axis=0)) #get the total population per year
df_tot.index = map(float, df_tot.index) #change the years to type float (useful for regression later on)
df_tot.reset_index(inplace=True) #reset the index to put in back in as a column in the df_tot dataframe
df_tot.columns = ['year', 'total'] #rename columns
# Generate the plot
plt.figure(figsize=(15, 10)) #graph size
sns.set(font_scale=1.5) #font size
sns.set_style('whitegrid') #change background; 'ticks' for white
ax = sns.regplot(x='year', y='total', data=df_tot, color='green', marker='+', scatter_kws={'s': 200}) #200 for markers size
ax.set(xlabel='Year', ylabel='Total Immigration')
ax.set_title('Total Immigration to Canada from 1980 - 2013')

# MAPS WITH FOLIUM

# Basic maps
#!conda install -c conda-forge folium=0.5.0 --yes #if required
import folium
world_map = folium.Map(location=[56.130, -106.35], zoom_start=4) #location Canada
world_map #display world map, names in local language
# Stamen Toner Maps - high-contrast B+W
world_map = folium.Map(location=[56.130, -106.35], zoom_start=4, tiles='Stamen Toner')
# Stamen Terrain Maps
world_map = folium.Map(location=[56.130, -106.35], zoom_start=4, tiles='Stamen Terrain')
# Mapbox Bright Maps - low zoom no borders, names in EN
world_map = folium.Map(tiles='Mapbox Bright')

# Map with Markers
df_incidents = pd.read_csv('https://...2016_.csv')
latitude = 37.77 #place of interest location
longitude = -122.42
sanfran_map = folium.Map(location=[latitude, longitude], zoom_start=12) #create map
# loop through the 100 crimes and add each to the map
for lat, lng, label in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):
    folium.features.CircleMarker(
        [lat, lng],
        radius=5, # size of circle markers
        color='yellow',
        fill=True,
        popup=label,
        fill_color='blue',
        fill_opacity=0.6
    ).add_to(sanfran_map)
sanfran_map

# Map with clasters of markers
from folium import plugins
# start with a clean copy of the map of San Francisco
sanfran_map = folium.Map(location = [latitude, longitude], zoom_start = 12)
# instantiate a mark cluster object for the incidents in the dataframe
incidents = plugins.MarkerCluster().add_to(sanfran_map)
# loop through the dataframe and add each data point to the mark cluster
for lat, lng, label, in zip(df_incidents.Y, df_incidents.X, df_incidents.Category):
    folium.Marker(
        location=[lat, lng],
        icon=None,
        popup=label,
    ).add_to(incidents)
sanfran_map #display map

# Choropleth Maps
world_geo = r'world_countries.json'
# create a numpy array of length 6 and has linear spacing from the minium total immigration to the maximum total immigration
threshold_scale = np.linspace(df_can['Total'].min(), df_can['Total'].max(), 6, dtype=int)
threshold_scale = threshold_scale.tolist() # change the numpy array to a list
threshold_scale[-1] = threshold_scale[-1] + 1 # make sure that the last value of the list is greater than the maximum immigration
# let Folium determine the scale.
world_map = folium.Map(location=[0, 0], zoom_start=2, tiles='Mapbox Bright')
world_map.choropleth(
    geo_data=world_geo,
    data=df_can,
    columns=['Country', 'Total'], #will be used to create the Choropleth map
    key_on='feature.properties.name', #key or variable of interest in the GeoJSON, countries in this case, it's case sensitive
    threshold_scale=threshold_scale,
    fill_color='YlOrRd', 
    fill_opacity=0.7, 
    line_opacity=0.2,
    legend_name='Immigration to Canada',
    reset=True)
world_map
